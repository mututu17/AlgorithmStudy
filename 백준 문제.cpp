#define _CRT_SECURE_NO_WARNINGS
#include <iostream> 
#include <string.h> 
#include <stdlib.h> // atoi 함수 라이브러리
#include <string> // to_string 함수 라이브러리

using namespace std;
int Min(int a, int b) { return a < b ? a : b; } // 조건식 : 메인문 위에서 이런식으로 쓰는 걸 처음 알게되었다.
int dp[1001][10];
int main()
{
	/* 11057 오르막 수
오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.
예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.
수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.
출력 : 첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.
*/
// 결국 이것도 풀지 못하였다..
	cout << "\n" << "11057 오르막 수" << endl;
	int num, count = 0;;
	cin >> num;

	for (int i = 0; i < 10; i++) { //길이, 끝나는 숫자
		dp[1][i] = 1;              //이거  코드가 밑에 있으면 for문에 쓰는 i,j가 안에서 변수 선언해도 에러가 뜨는데 이유가 뭘까
	}								//식이 개체 포인터 형식에 있어야 하는데 int 형식이 있음(에러) 지역변수인데..

	for (int i = 2; i <= num; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 0) {
				dp[i][j] = 1;
				continue;
			}
			dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 10007;
		}
	}

	for (int i = 0; i < 10; i++) {
		count += dp[num][i];
	}
	cout << count % 10007;
	// 출처 : https://heespace.tistory.com/21

	/* 10824 네 수 
	네 자연수 A, B, C, D가 주어진다. 이때, A와 B를 붙인 수와 C와 D를 붙인 수의 합을 구하는 프로그램을 작성하시오.
	두 수 A와 B를 합치는 것은 A의 뒤에 B를 붙이는 것을 의미한다. 즉, 20과 30을 붙이면 2030이 된다.
	*/
	cout << "\n" << "10824 네 수" << endl;
	char A[100], B[100], C[100], D[100] = {};
	cin >> A >> B >> C >> D;
	strcat(A, B);
	strcat(C, D);
	cout << A << "\n" << C << endl; 
	  
	int sum_A,sum_C,result;
	
	sum_A = atoi(A);     // 문자열 -> 정수로 바꾸는 함수 atoi( ) 사용
	sum_C = atoi(C);	 // 반대로 to_stirng(A)로  정수 -> 문자열로도 가능 

	result = sum_A + sum_C;
	cout << result << endl;   // 근데 틀림 ㅋㅋ..뭐지 

	// 처음에 함수없이 구현하려고 했지만 실패, 문자열을 저장할 때 자료형 char 와 정수 자료형 int의 크기가 맞지않는 오류발생
	//  에러발생 Run-Time Check Failure :지역변수의 주소(포인터)를 이용해서 그 변수에 값을 저장할 때, 실제로 변수에 할당된 크기보다 더 큰 타입으로 기록하려고 할 때 발생.
	
	/* 1699 제곱수의 합
	어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=32+12+12(3개 항)이다. 
	이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다.
	주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.
	*/
	// 지난번의 복수를 하려 했지만 그대로 숙청당해버린 나....어케하는데... 
	
	cout << "\n" << "1669 제곱수의 합" << endl;
	int n, dp[100001];
	cin >> n;
	for (int k = 0; k <= n; k++) dp[k] = k;  //  이런 형태의 반복문 표현도 익혀둬야겠다. 근데 줄바꿈 안하면 교수님이 별로인 코드라고 하시던데..
	for (int p = 2; p <= n; p++)
	{
		for (int q = 2; q * q <= p; q++) 
		{
			dp[p] = Min(dp[p], dp[p - q * q] + 1);  // 최소개수 조건식 int Min(int a, int b) { return a < b ? a : b; } a가 b보다 작으면 a,아님 b
														// +1을 해주는 이유 : N에서 해당되는 수의 제곱수를 빼고 그 수에 제곱수를 더하기 때문에 
		}													// 해당 수를 빼는 경우의 수 1을 더해줘야 한다.
	}
	cout << dp[n] << endl;
	// [출처] [백준] 1699 - 제곱수의 합 | 작성자 occidere
	cout << "\n" << "이천수" << endl;
	/* 2193 이친수
	이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.
	이친수는 0으로 시작하지 않는다.
	이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
	N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
	*/
	// 앞자리는 무조건 1이라는 소리네 , 근데 자리수 관점에 따라서, ex) 2자리수에서의 1 -> 01 이니까 1도 안되는거 아닌가라고 생각이 드는 중..*아니였다.
	int N;
	cin >> N;
	long long int dP_N[91];  // long long 8바이트인데 왜 안돼... -> 아 배열 [90]이 아니라 [91]이여하네.. 멍청이..
	dP_N[0] = 0;		// 1의 자리수 : 1
	dP_N[1] = 1;		// 10의 자리수 : 10 
	for (int i = 2; i <= N; i++)  // 3의 자리수 부터
	{  
		dP_N[i] = dP_N[i - 1] + dP_N[i - 2];    
	}
	cout << dP_N[N] << endl;  // N이 90일 때 자리수 오버플로우 발생 -> *크기가 90이면 배열 요소는 0~89까지임  


	return 0;
}